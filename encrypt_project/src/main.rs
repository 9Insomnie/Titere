use std::{fs::{File, read_dir}, io::{Read, Write}};

// ============================================================================
// 多态代码区域 - 用于混淆和反检测
// 这些函数看起来是正常的业务逻辑，实际用于混淆真实意图
// ============================================================================
fn dummy_func_1() { 
    // 模拟数学计算
    let _ = 2024 * 3; 
}
fn dummy_func_2() { 
    // 模拟字符串处理
    let s = "data".to_string(); 
    let _ = s.find('a'); 
}
fn dummy_func_3() { 
    // 模拟数组操作
    let v: Vec<u8> = (10..20).collect(); 
    let _ = v.len(); 
}

// ============================================================================
// 主程序入口 - 文件加密处理工具
// ============================================================================
fn main() {
    // ========================================================================
    // 第一阶段：文件检测和选择
    // ========================================================================
    // 自动扫描当前目录，查找第一个可用的.bin文件
    // 排除output.bin文件，避免重复处理
    let input_file = read_dir(".")
        .expect("无法读取当前目录")
        .filter_map(|e| e.ok())
        .map(|e| e.path())
        .filter(|p| {
            p.is_file() && 
            p.extension().map(|ext| ext == "bin").unwrap_or(false) && 
            p.file_name().map(|n| n != "output.bin").unwrap_or(true)
        })
        .next()
        .expect("未找到可用的 .bin 文件");
    println!("检测到输入文件: {}", input_file.display());

    // ========================================================================
    // 第二阶段：文件读取
    // ========================================================================
    // 读取目标文件的所有内容到内存缓冲区
    let mut f = File::open(&input_file).expect("无法打开输入文件");
    let mut buffer = Vec::new();
    f.read_to_end(&mut buffer).expect("读取数据失败");

    // ========================================================================
    // 第三阶段：数据加密处理
    // ========================================================================
    // 使用固定的XOR密钥对数据进行加密/解密处理
    // 密钥：0x1A, 0x2B, 0x3C, 0x4D, 0x5E, 0x6F, 0x7A, 0x8B
    let key: [u8; 8] = [0x1A, 0x2B, 0x3C, 0x4D, 0x5E, 0x6F, 0x7A, 0x8B];
    let processed: Vec<u8> = buffer.iter()
        .enumerate()
        .map(|(i, &b)| b ^ key[i % key.len()])  // 循环使用密钥进行XOR运算
        .collect();

    // ========================================================================
    // 第四阶段：结果输出
    // ========================================================================
    // 将处理后的数据写入output.bin文件
    let mut fout = File::create("output.bin").expect("无法创建output.bin");
    fout.write_all(&processed).expect("写入output.bin失败");
    println!("处理完成，输出文件: output.bin");

    // ========================================================================
    // 第五阶段：清理和混淆
    // ========================================================================
    // 调用多态垃圾代码，增加代码复杂度，混淆真实意图
    dummy_func_1();
    dummy_func_2();
    dummy_func_3();
}